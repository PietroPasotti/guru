import dataclasses
import json
import logging
import re
import shlex
import subprocess
import tempfile
import time
import typing
from collections import defaultdict
from pathlib import Path
from typing import (
    Any,
    Dict,
    Iterable,
    List,
    Optional,
    Tuple,
    Union,
    cast,
)

import scenario
import sh

logger = logging.getLogger("guru")


class GuruError(Exception):
    """Base of the Guru exception hierarchy."""


class WaitError(GuruError):
    """Raised when Guru.wait errors out."""


class NotFoundError(GuruError):
    """Raised when a user operation on Guru attempts to manipulate an object that is not in the model state."""


class InvalidOperationError(GuruError):
    """Raised when a user operation on Guru would make the model state inconsistent."""


GURU_MODEL_PREFIX = "guru-"


class CheckFailed(GuruError):
    """Raised when a built-in check fails."""


def _random_model_name():
    import random
    import string

    space = string.ascii_lowercase + string.digits + "-"
    # cannot start or end with hyphen
    return GURU_MODEL_PREFIX + ("".join(random.choice(space) for _ in range(20)).strip("-"))


@dataclasses.dataclass(frozen=True)
class Model:
    """A Juju model which Guru can control."""

    name: str = dataclasses.field(default_factory=_random_model_name)
    """The name of the model."""
    controller: Optional[str] = None
    """The name of the controller this model is owned by."""
    # uuid: str = dataclasses.field(default_factory=lambda: str(uuid4()))
    # """A unique identifier for the model, typically generated by Juju."""

    # whatever juju models --format=json | jq '.models[<current-model-index>].type' gives back.
    # TODO: make this exhaustive.
    type: typing.Literal["kubernetes", "lxd"] = "kubernetes"
    """The type of Juju model."""

    # cloud_spec: Optional[CloudSpec] = None
    # """Cloud specification information (metadata) including credentials."""


class _CharmSource:
    deploy_url: str  # override in subclasses

    @property
    def deploy_args(self) -> List[str]:
        return []


class _CharmhubSource(_CharmSource):
    def __init__(self, name: str,
                 channel: Optional[str] = None,
                 revision: Optional[int] = None
                 ):
        self.deploy_url = name
        self.channel = channel
        self.revision = revision

    @property
    def deploy_args(self) -> List[str]:
        args = []
        if self.channel:
            args += ["--channel", self.channel]
        if self.revision is not None:
            args += ["--revision", self.revision]
        return args


class _LocalSource(_CharmSource):
    def __init__(self, path: Path,
                 meta: Optional[Dict[str, Any]] = None
                 ):
        self.path = path
        self.meta = meta
        self.deploy_url = str(path.absolute())


@dataclasses.dataclass(frozen=True)
class _CharmSpec:
    source: _CharmSource
    name: str
    """Name of the charm."""


_MOD_CONFIG = "config"
_MOD_SCALE = "scale"


@dataclasses.dataclass
class App:
    """Application.

    Not meant to be instantiated directly.
    """

    charm: _CharmSpec
    """Charm that this app deploys."""
    alias: Optional[str] = None
    """Name with which this app is deployed to juju."""

    _deploy_spec = None

    @staticmethod
    def from_charmhub(
            charm: str,
            alias: Optional[str] = None,
            channel: str = "stable",
            revision: Optional[int] = None,
    ):
        return App(
            _CharmSpec(
                source=_CharmhubSource(
                    charm,
                    channel=channel,
                    revision=revision,
                ),
                name=charm,
            ),
            alias=alias

        )

    @staticmethod
    def from_git(
            org: str,
            repo_name: str,
            name: Optional[str] = None,
            branch: Optional[str] = None,
    ):
        """Load app from a git repo."""
        # url = f"git@github.com:{org}/{repo_name}"
        url = f"http://github.com/{org}/{repo_name}"

        destination = tempfile.TemporaryDirectory()
        _branch = f" --branch {branch}" if branch else ""
        cmd = f"git clone {url} --depth 1{_branch} {destination.name}"

        try:
            subprocess.check_call(shlex.split(cmd))
        except subprocess.CalledProcessError as e:
            raise RuntimeError(
                f"failed cloning {url}@{branch if branch else 'main'} with {cmd!r}"
            ) from e

        charm_root = Path(destination.name)
        if not charm_root.exists():
            raise RuntimeError(
                f"{charm_root} not found: cannot import charm from path."
            )

        # TODO: charmcraft pack

        raise NotImplementedError()

    def __eq__(self, other: "App"):  # pyright: ignore[reportIncompatibleMethodOverride]
        if not isinstance(other, App):
            raise RuntimeError(f"cannot __eq__(App, {type(other).__name__}")
        return self.name == other.name

    def __hash__(self):
        # app names are going to be model-unique anyway.
        return hash(self.name)

    def __repr__(self):
        return f"<App: {self.name}>"

    # deploy modifiers for ModelState init
    def _set_modifier(self, key: str, value: Any):
        if not self._deploy_spec:
            self._deploy_spec = {}
        self._deploy_spec[key] = value
        return self

    def _get_modifier(self, key: str):
        if self._deploy_spec:
            return self._deploy_spec.get(key)
        return None

    @property
    def scale(self) -> int:
        return self._get_modifier(_MOD_SCALE) or 1

    def with_scale(self, scale: int) -> typing.Self:
        """Deploy this number of units with this app (if unset, default is 1)."""
        return self._set_modifier(_MOD_SCALE, scale)

    def with_config(self, config: Dict[str, str]) -> typing.Self:
        """Deploy this app with this config."""
        return self._set_modifier(_MOD_CONFIG, config)

    # conditions for Guru.settle
    def is_active(self):
        return StatusCondition(self, 'active')

    def is_blocked(self):
        return StatusCondition(self, 'blocked')


class Condition:
    def check(self, guru: "Guru") -> bool:
        raise NotImplementedError

    def __and__(self, other: "Condition"):
        return AndCondition(self, other)

    def __or__(self, other: "Condition"):
        return OrCondition(self, other)


class _BinaryPredicateCondition(Condition):
    def __init__(self, condition_1: Condition, condition_2: Condition):
        self.condition_1 = condition_1
        self.condition_2 = condition_2


class _UnaryPredicateCondition(Condition):
    def __init__(self, condition: Condition):
        self.condition = condition


class NotCondition(_UnaryPredicateCondition):
    def check(self, guru: "Guru") -> bool:
        return not self.condition.check(guru)


class AndCondition(_BinaryPredicateCondition):
    def check(self, guru: "Guru") -> bool:
        return self.condition_1.check(guru) and self.condition_2.check(guru)


class OrCondition(_BinaryPredicateCondition):
    def check(self, guru: "Guru") -> bool:
        return self.condition_1.check(guru) or self.condition_2.check(guru)


class StatusCondition(Condition):
    def __init__(self, app: App, status: str, message: str = None):
        self.app = app
        self.status = status
        self.message = message

    def check(self, guru: "Guru") -> bool:
        status = guru.cli.status()
        app_status = status[self.app]
        if not self.status == app_status.status:
            return False
        if self.message and not app_status.message == self.message:
            return False
        return True


@dataclasses.dataclass(frozen=True)
class Binding:
    """Integration endpoint binding."""

    app: App
    endpoint: str
    relation_id: int = dataclasses.field(
        default_factory=scenario.state.next_relation_id
    )

    def __repr__(self):
        return f"<Binding {self.app.name}:{self.endpoint} ({self.relation_id})>"


@dataclasses.dataclass(frozen=True)
class Integration:
    """Juju integration."""

    binding1: Binding
    binding2: Binding

    @staticmethod
    def from_endpoints(app1: App, endpoint1: str, app2: App, endpoint2: str):
        """Construct an Integration object from its endpoints."""
        return Integration(Binding(app1, endpoint1), Binding(app2, endpoint2))

    @property
    def apps(self) -> Tuple[App, App]:
        """Apps partaking in this integration."""
        return self.binding1.app, self.binding2.app

    @property
    def relations(self) -> Tuple[scenario.Relation, scenario.Relation]:
        """Relations."""
        return (
            scenario.Relation(
                endpoint=self.binding1.endpoint,
                remote_app_name=self.binding2.app.alias,
                relation_id=self.binding1.relation_id,
            ),
            scenario.Relation(
                endpoint=self.binding2.endpoint,
                remote_app_name=self.binding1.app.alias,
                relation_id=self.binding2.relation_id,
            ),
        )

    def __iter__(self):
        yield from (self.binding1.app, self.binding1.endpoint, self.binding2.app, self.binding2.endpoint)


class UnitStatus:
    """Juju unit status wrapper."""

    def __init__(self, name: str, raw: Dict[str, Any]):
        self.name = name  # such as traefik/0
        self.raw = raw
        self.juju_status = raw['juju-status']['current']
        self.status = raw['workload-status']['current']
        self.message = raw['workload-status'].get('message')


class AppStatus:
    """Juju app status wrapper."""

    def __init__(self, raw: Dict[str, Any]):
        self.raw = raw
        self.status = raw['application-status']['current']
        self.message = raw['application-status'].get('message')
        self.units = {
            int(unit.split('/')[1]): UnitStatus(unit, unit_raw) for unit, unit_raw in raw['units'].items()
        }


ANSI_ESCAPE = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')


def _strip_ansi(s: str):
    return ANSI_ESCAPE.sub('', s)


class JujuStatus:
    """Juju status wrapper."""

    def __init__(self, raw: str):
        self._raw = json.loads(_strip_ansi(raw))

    def __getitem__(self, item: App):
        alias = item.alias
        if alias not in self._raw['applications']:
            raise NotFoundError(alias)
        return AppStatus(self._raw['applications'][alias])


@dataclasses.dataclass(frozen=True)
class ModelState:
    """Model state."""
    apps: List[App] = dataclasses.field(default_factory=list)
    integrations: List[Integration] = dataclasses.field(default_factory=list)
    model: Model = dataclasses.field(default_factory=Model)

    def __str__(self):
        no_units = sum([app.scale for app in self.apps])
        return f"<ModelState ({len(self.apps)} apps, {no_units} units)>"


class JujuCLI:
    def __init__(self, model: Model):
        self._model = model
        self.juju = sh.juju

    def add_model(self, name: str):
        return self.juju("add-model", name)

    def deploy(self, app: App, scale: int = 1):
        logger.info(f"deploying {app.charm.name} to {self._model.name}" + (f" as {app.alias}" if app.alias else ""))
        return self.juju("deploy", "-m", self._model.name,
                         "-n", scale,
                         *app.charm.source.deploy_args,
                         app.charm.source.deploy_url,
                         app.alias or app.charm.name)

    def status(self, relations: bool = False) -> JujuStatus:
        args = ("status", *(["--relations"] if relations else []), "-m",
                self._model.name, "--format", "json")
        return JujuStatus(self.juju(*args))

    def integrate(self, app1: App, endpoint1: str, app2: App, endpoint2: str):
        args = ("integrate", f"{app1.alias}:{endpoint1}", f"{app2.alias}:{endpoint2}")
        return JujuStatus(self.juju(*args))


class Guru:
    """Integration testing tool for juju."""

    def __init__(self, model_state: Optional[ModelState] = None, apply: bool = True):
        self._model_state = model_state or ModelState()
        self.cli = JujuCLI(self._model_state.model)

        if apply:
            self.apply()

    @staticmethod
    def from_model(name: str):
        # todo: generate model state from status
        return Guru(model_state=ModelState(model=Model(name)), apply=False)

    @property
    def model_state(self) -> ModelState:
        """The model state attached to this Guru."""
        return self._model_state

    def apply(self):
        """Apply initial state to match."""
        logger.info(f"Creating model {self.model_state.model.name}")
        self.cli.add_model(self.model_state.model.name)
        for app in self.model_state.apps:
            self.cli.deploy(app, app.scale)
        for integration in self.model_state.integrations:
            self.integrate(*integration)

    def wait(
            self,
            wait_condition: Condition,
            *,
            error_condition: Condition = None,
            check_interval: int = 3,  # in seconds
            timeout: int = 15 * 60,  # in seconds
            idle_period: int = 0  # in seconds
    ) -> bool:
        """Wait for a given condition."""

        elapsed = 0
        while True:
            if elapsed > timeout:
                raise WaitError("timeout reached")

            time.sleep(check_interval)
            elapsed += check_interval
            if wait_condition.check(self):
                return True

            if error_condition.check(self):
                raise WaitError("error condition triggered", error_condition)

    def fire(
            self,
            event: Union[str, scenario.Event],
            app: App,
            unit_id: int,
            update_model_state: bool = True,
    ) -> scenario.State:
        """Execute a single event and return the unit state.

        `event`: The event to fire.
        `app`: App on which to fire the event.
        `unit_id`: ID of the unit on which to fire the event.
        `update_model_state`: whether any changes to the unit state should be recorded in the model
          state attached to this Guru.
        """
        item = _QueueItem(
            app=app,
            unit_id=unit_id,
            event=event if isinstance(event, scenario.Event) else scenario.Event(event),
        )

        ms_out = self._step(item)
        if update_model_state:
            self._model_state = ms_out
        return ms_out.unit_states[app][unit_id]

    @staticmethod
    def _find_relation(
            state: scenario.State, local_binding: Binding, remote_binding: Binding
    ):
        """Find a unique relation corresponding to this integration in the state.

        Raises an exception if multiple are found.
        """
        others = []
        found = None
        for rel in state.relations:
            if not isinstance(rel, scenario.Relation):
                continue

            if (
                    rel.remote_app_name == remote_binding.app.name
                    and rel.endpoint == local_binding.endpoint
            ) or (rel.endpoint == local_binding.endpoint):
                if found:
                    raise RuntimeError(
                        f"Multiple relations found matching {local_binding.endpoint} -> {remote_binding.endpoint}"
                    )
                found = rel
            else:
                others.append(rel)

        if not found:
            raise NotFoundError(
                f"relation {local_binding.endpoint} -> {remote_binding.app.name}:"
                f"{remote_binding.endpoint} not found in state"
            )
        return found, others

    def _add_integration(self, integration: Integration):
        """Add an integration to the model.

        This method will NOT validate that the interface you're creating is valid.
        Caller's responsibility.
        """
        ms_out = self._model_state.replace(
            integrations=self._model_state.integrations + [integration]
        )
        for relation, app, other_app in zip(
                integration.relations, integration.apps, reversed(integration.apps)
        ):
            with self.fixed_sequence():
                self._queue(ms_out, relation.created_event, app)

                for remote_unit_id in ms_out.unit_states[other_app]:
                    self._queue(
                        ms_out,
                        relation.joined_event(remote_unit_id=remote_unit_id),
                        app,
                    )

                self._queue(ms_out, relation.changed_event, app)

        self._model_state = ms_out
        return ms_out

    def _get_interfaces(
            self, apps: Iterable[App]
    ) -> Tuple[Dict[str, List[Tuple[App, str]]], Dict[str, List[Tuple[App, str]]]]:
        # Get a mapping from all supported interfaces in the current model to the list of
        #  app:endpoint pairs that support them. Split by provider and requirer

        # mapping from apps to interfaces to endpoints
        providers = defaultdict(list)
        requirers = defaultdict(list)

        pool = apps or list(self._model_state.unit_states)

        for _app in pool:
            # mapping from interfaces to app, endpoint pairs
            for endpoint, ep_meta in _app.charm.meta.get("provides", {}).items():
                providers[ep_meta["interface"]].append((_app, endpoint))

            for endpoint, ep_meta in _app.charm.meta.get("requires", {}).items():
                requirers[ep_meta["interface"]].append((_app, endpoint))

        # interfaces that have both a requirer and a provider in the pool of apps under consideration
        # sorting is to make our lives easier in testing
        return providers, requirers

    def integrate(
            self,
            app1: App,
            endpoint1: str,
            app2: App,
            endpoint2: str,
    ):
        """Integrate two apps."""
        self.cli.integrate(app1, endpoint1, app2, endpoint2)

    def get_app(self, name: str) -> App:
        """Get an app by name."""
        return [a for a in self._model_state.unit_states if a.name == name][0]

    def get_integration(self, app1: App, endpoint: str, app2: App) -> Integration:
        """Get an integration."""
        to_remove = None
        ms = self._model_state

        for integration in ms.integrations:
            if (
                    integration.binding1.app == app1
                    and integration.binding2.app == app2
                    and integration.binding1.endpoint == endpoint
            ):
                to_remove = integration
                break
            if (
                    integration.binding1.app == app2
                    and integration.binding2.app == app1
                    and integration.binding1.endpoint == endpoint
            ):
                app1, app2 = app2, app1
                to_remove = integration
                break

        if not to_remove:
            raise NotFoundError(f"Integration not found: {app1}:{endpoint} --> {app2}")

        return to_remove

    def run_action(
            self,
            action: Union[str, scenario.Action],
            app: App,
            unit: Optional[int] = None,
    ):
        """Run an action on all units or a specific one."""
        if not isinstance(action, scenario.Action):
            action = scenario.Action(action)
        if app not in self.model_state.unit_states:
            raise InvalidOperationError(
                f"app {app} not in model state: cannot queue action."
            )
        if unit is not None and unit not in self.model_state.unit_states[app]:
            raise InvalidOperationError(
                f"app {app}/{unit} not in model state: cannot queue action."
            )

        self._queue(self._model_state, cast(scenario.Action, action).event, app, unit)

    def _queue_setup_sequence(self, app: App, unit: Optional[int] = None):
        """Queues setup phase event sequence for this app/unit."""

        model_state = self._model_state

        app_unit_states = model_state.unit_states[app]
        peer_ids = list(app_unit_states)

        with self.fixed_sequence():
            self._queue(model_state, "install", app, unit)
            # todo storage attached events

            # FIXME: peer relation ids need to be unified, because we don't have
            #  something like Integrations for peers. Perhaps self._peer_relation_ids[app][endpoint] ?
            # now queue all peer-relation events and create the peer
            # relations if they don't exist already
            if self._auto_create_peer_relations_on_deploy:
                for peer_id in peer_ids:
                    base_state = app_unit_states[peer_id]
                    other_units = [i for i in peer_ids if i != peer_id]
                    relations = self._add_peer_relations(
                        app, peer_id, other_units, base_state.relations
                    )
                    app_unit_states[peer_id] = base_state.replace(relations=relations)

            for _unit in app_unit_states:
                is_leader = app_unit_states[_unit].leader
                self._queue(
                    model_state,
                    "leader-elected" if is_leader else "leader-settings-changed",
                    app,
                    _unit,
                )
            self._queue(model_state, "config-changed", app, unit)
            self._queue(model_state, "start", app, unit)

    def get_unit_state(
            self, app: App, unit_id: int, model_state: Optional[ModelState] = None
    ):
        """Fetch the state of a single unit from the model state."""
        _model_state = model_state or self._model_state
        try:
            return model_state.unit_states[app][unit_id]
        except KeyError:
            return self._dead_unit_states[app][unit_id]

    def add_unit(
            self,
            app: App,
            unit_id: Optional[int] = None,
            state: Optional[scenario.State] = None,
            emit_pebble_ready: Optional[bool] = None,
    ):
        """Adds a unit to this application.

        Params:
        `app`: App you intend to scale up.
        `unit_id`: ID of the newly created unit.
          If None, we'll take the current max unit ID for this app (or 0, if no units are found)
          and add 1.
        `state`: state of the new unit. Will default to the empty state if None.
        `emit_pebble_ready`: Whether we should queue a pebble-ready event for all containers in
          the state as part of the startup sequence.
        """
        model_state = self._model_state
        new_states = model_state.unit_states.copy()

        peers = new_states[app]
        unit_id = unit_id if unit_id is not None else max(peers or (0,)) + 1
        state = state or scenario.State()
        if unit_id in peers:
            raise InvalidOperationError(
                f"{app.name}/{unit_id} exists already in the model state"
            )

        if peers:
            if state.leader:
                # todo consider doing state.replace(leader=False) instead of raising
                raise InvalidOperationError("new units cannot join as leaders.")
        else:
            if not state.leader:
                logger.info(
                    f"new unit {unit_id} is the first unit of {app}: setting leader=True"
                )
                state = state.replace(leader=True)

        # add any containers
        if self._auto_create_containers_on_deploy:
            state = self._add_containers(state, app)

        # make sure the config is the same
        if peers:
            # only do this check if we have peers: if we're the first unit our config
            # is the one that matters
            leader_config = self._get_leader_state(app).config

            if state.config != leader_config:
                if self._auto_fix_diverged_config_on_deploy:
                    logger.debug(
                        f"new config for {app}/{unit_id} fixed to match the leader's."
                    )
                    state = state.replace(config=leader_config)
                else:
                    raise InconsistentStateError(
                        f"the config for {app}/{unit_id} should match "
                        f"that of the application leader."
                    )

        peers[unit_id] = state
        new_model_state = model_state.replace(unit_states=new_states)

        self._model_state = new_model_state
        # this also queues the peer relation events and adds any peer relations
        self._queue_setup_sequence(app, unit_id)

        if self._should_emit_pebble_ready_on_setup(emit_pebble_ready):
            self.pebble_ready(app, unit_id)

        return new_model_state

    def imatrix_clear(self, *app: App) -> List[Integration]:
        """Remove all relations (involving app)."""
        gone = []
        for integration in list(self._model_state.integrations):
            if app:
                if any(a in integration.apps for a in app) and integration not in gone:
                    self.disintegrate(integration)
                    gone.append(integration)
            else:
                self.disintegrate(integration)
                gone.append(integration)
        return gone

    def imatrix_fill(self, *app: App) -> List[Integration]:
        """Cross-relate all that's relatable (only including *app)."""

        # interfaces that have both a requirer and a provider in the pool of apps under consideration
        providers, requirers = self._get_interfaces(apps=app)

        integrations = []
        # sorting is to make our lives easier in testing
        for shared_interface in sorted(set(providers).intersection(set(requirers))):
            for prov_app, prov_ep in providers[shared_interface]:
                for req_app, req_ep in requirers[shared_interface]:
                    integration = Integration(
                        Binding(prov_app, prov_ep),
                        Binding(req_app, req_ep),
                    )
                    self._add_integration(integration)
                    integrations.append(integration)

        return integrations

    def configure(self, app: App, **_config):
        """Update the app configuration."""
        model_state = self._model_state
        new_states = model_state.unit_states.copy()
        leader_state = self._get_leader_state(app)
        if not leader_state:
            raise InvalidOperationError(f"{app} has no leader: cannot configure.")

        config = leader_state.config
        config.update(_config)

        new_unit_states = {}
        for _id, _unit_state in new_states[app].items():
            new_unit_state = _unit_state.replace(config=config)

            self._consistency_check(
                consistency_checker.check_config_consistency(
                    state=new_unit_state,
                    charm_spec=app.charm,
                    juju_version=JUJU_VERSION,
                ),
                operation=f"configure {app.name} {_config}",
            )

            new_unit_states[_id] = new_unit_state

        new_states[app] = new_unit_states
        new_model_state = model_state.replace(unit_states=new_states)

        self._queue(new_model_state, "config-changed", app)

        self._model_state = new_model_state
        return new_model_state

    def remove_app(self, app: App):
        """Remove an app."""
        model_state = self._model_state
        new_states = model_state.unit_states.copy()

        if app not in new_states:
            raise NotFoundError(f"app {app} not in ModelState")

        all_unit_states = new_states.pop(app)
        # in case we've previously killed some units of this app:
        all_unit_states.update(self._dead_unit_states[app])
        self._dead_unit_states[app] = all_unit_states

        new_model_state: ModelState = model_state.replace(unit_states=new_states)
        # set this first so that _queue_setup_sequence will use it
        self._model_state = new_model_state

        # remove all integrations where app is involved BEFORE nuking the app
        self.imatrix_clear(app)

        # we could call _queue_teardown_sequence(app), but depending on who's the leader that might
        # trigger a lot more events than we'd like. If we're destroying the app there's no point
        # in electing a new leader each time, so instead we nuke the leader last,
        # to prevent any bouncing.
        follower_ids = list(all_unit_states)
        leader_id = [i for i, s in all_unit_states.items() if s.leader][0]
        follower_ids.remove(leader_id)
        for follower_id in follower_ids:
            self._queue_teardown_sequence(app, follower_id)
        self._queue_teardown_sequence(app, leader_id)

        return new_model_state

    def scale(self, app: App, target: int) -> ModelState:
        """Scale an app up or down, by setting its unit count to `n`.

        If scaling up:
         - Any newly created units will have IDs increasing from the highest one currently in
           the model state.
         - The state of the newly created units will, too, be copied from the one with the highest ID.
        If scaling down:
         - Units with the lowest ID will be removed first (to avoid a flurry of leader re-elections,
           because if the leader is removed, the unit with the highest ID is elected by default).

        Params:
        `app`: app that you want to scale up or down.
        `target`: target number of units this app should have.
        """
        unit_states = self.model_state.unit_states[app]
        max_id = max(unit_states)
        current_count = len(unit_states)

        if target > current_count:
            logger.info(f"scaling up {app} from {current_count} to {target}")
            for i in range(target - current_count):
                self.add_unit(app, max_id + i + 1, state=unit_states[max_id].copy())

        elif target < current_count:
            logger.info(f"scaling down {app} from {current_count} to {target}")
            current_ms = self._model_state
            for i in range(current_count - target):
                min_id = min(current_ms.unit_states[app])
                current_ms = self.remove_unit(app, min_id)

        else:
            raise InvalidOperationError(f"app {app} already has scale {target}.")

        return self._model_state

    def remove_unit(self, app: App, unit: int, new_leader_id: Optional[int] = None):
        """Remove a unit.

        Params:
        `app`: app that you want to scale down.
        `unit`: unit that you want to vanquish.
        `new_leader_id`: ID of the unit that should be elected leader, if the unit you are
          removing happens to be the leader one. Leave it blank, and it shall be the unit with
          the smallest ID.
        """
        model_state = self._model_state
        new_states = model_state.unit_states.copy()

        if app not in new_states:
            raise NotFoundError(f"app {app} not in ModelState")

        unit_state = new_states[app].pop(unit)
        self._dead_unit_states[app][unit] = unit_state

        new_model_state = model_state.replace(unit_states=new_states)

        if unit_state.leader:
            # killing the leader!
            if new_states[app]:
                new_leader_id = new_leader_id or min(list(new_states[app]))
                logger.debug(
                    f"killing the leader. Electing {new_leader_id} instead. "
                    f"Long live {app}/{new_leader_id}!"
                )

                new_states[app][new_leader_id] = new_states[app][new_leader_id].replace(
                    leader=True
                )
                self._queue(new_model_state, "leader-elected", app, new_leader_id)

            else:
                logger.debug(f"killing the last unit and leader, {app} scaled to zero.")

            self._queue(new_model_state, "leader-settings-changed", app, unit)

        # set this first so that _queue_setup_sequence will use it
        self._model_state = new_model_state
        self._queue_teardown_sequence(app, unit)

        return new_model_state

    def clear_queue(self):
        """Delete all items from the queue."""
        self._event_queue.clear()
        logger.info("Event queue cleared.")

    def _add_peer_relations(
            self,
            app: App,
            unit_id: int,
            peer_ids: List[int],
            existing_relations: List["AnyRelation"] = None,
    ) -> Iterable["AnyRelation"]:
        existing_relations = existing_relations or []
        bound_peer_endpoints = [
            r.endpoint
            for r in existing_relations
            if isinstance(r, scenario.PeerRelation)
        ]

        peers = []
        for peer_endpoint, peer_meta in app.charm.meta.get("peers", {}).items():
            if peer_endpoint in bound_peer_endpoints:
                # user created this manually already, let's skip it
                logger.debug(
                    f"skipping setup sequence for peer relation on {peer_endpoint}: "
                    f"relation in state already."
                )
                continue

            peer = scenario.PeerRelation(
                endpoint=peer_endpoint,
                interface=peer_meta["interface"],
                # point to all peer ids except your own
                peers_data={u: {} for u in peer_ids if u != unit_id},
            )
            peers.append(peer)
            self.queue(peer.created_event, app, unit_id)
            # notify this unit that each peer is joining
            for peer_id in peer_ids:
                self.queue(peer.joined_event(remote_unit_id=peer_id), app, unit_id)
            self.queue(peer.changed_event, app, unit_id)
        return existing_relations + peers

    def deploy(
            self,
            app: App,
            ids: Optional[Iterable[int]] = None,
            state_template: Optional[scenario.State] = None,
            leader_id: Optional[int] = None,
            emit_pebble_ready: bool = False,
    ) -> ModelState:
        """Deploy an app.

        `app`: The App to deploy
        `ids`: IDs of the units that should be created. If left None, a single unit of the app
          will be created, with ID 0.
        `state_template`: Blueprint of the scenario.State that should be assigned to all newly
          created units. If you need different states to be assigned to different units, you
          should use `deploy()` to deploy the leader, and `add_unit()` to add any follower units
          and assign to them the state you want.
        `leader_id`: ID of the unit that should be leader, selected amongst the `ids` you provided.
          Defaults to the first ID in the iterable you supplied.
        `emit_pebble_ready`: emit all pebble-ready events as part of the setup sequence.


        Example usage:
        >>> c = Guru()
        >>> c.deploy(
        ...    App.from_path("/path/to/my/charm/repo"),
        ...    ids=[0, 10, 24],  # create three units with id 0, 10 and 24
        ...    state_template=scenario.State(config={'foo': 'bar'}),
        ...    leader_id=10,  # unit 10 is leader
        ...    )
        """
        model_state = self._model_state

        return new_model_state

    def check_status(
            self,
            app,
            *unit: int,
            name: str,
            app_status: bool = False,
            message: Optional[str] = None,
            _raise: bool = True,
            model_state: Optional[ModelState] = None,
    ):
        """Utility to check the status of an app/unit in the current model state."""
        ms = model_state or self.model_state
        unit_states = ms.unit_states[app]
        unit_ids = unit or list(unit_states)

        failures = []

        for unit_id in unit_ids:
            state = unit_states[unit_id]
            target = getattr(state, "app_status" if app_status else "unit_status")
            if target.name != name:
                failures.append(target)
            elif message is not None and target.message != message:
                failures.append(target)

        result = not failures
        if _raise and not result:
            raise CheckFailed(failures)
        return result

    @staticmethod
    def _add_containers(state: scenario.State, app: App):
        existing_containers = set(c.name for c in state.containers)
        required_containers = set(app.charm.meta.get("containers", ()))
        missing_containers = required_containers.difference(existing_containers)
        logger.debug(f"adding missing containers to {app}: {missing_containers}")

        return state.replace(
            containers=state.containers
                       + [
                           scenario.Container(container_name)
                           for container_name in missing_containers
                       ]
        )

    def _get_leader_state(self, app: App) -> Optional[scenario.State]:
        leaders = [
            state
            for state in self._model_state.unit_states[app].values()
            if state.leader
        ]

        if not leaders:
            return None

        if len(leaders) > 1:
            raise InconsistentStateError(f"{app} has too many leaders")
        return leaders[0]
